{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to nea89s Modding Wiki","text":"<p>This wiki is aimed at mod developers for Minecraft 1.8.9 and those who want to be. More specifically, this wiki is here for client mods for Hypixels SkyBlock.</p> <p>First a word of warning: Modding isn't always for the faint of heart. Mojang doesn't really intend for people to mod their game, so there isn't exactly a lot of documentation laying around. What little documentation you will find is probably for newer versions and most mod dev forums either can't or don't want to help you with an 8 year old minecraft version. But while starting with a mod as your first programming project isn't great and it helps to know your ways around Java as well, if you are passionate then I believe you can do it!</p> <p>Despite all that, there is still a community around modding for SkyBlock. You don't have to go into this alone, you can always join up with an existing modding team, which also helps beating the ratting allegations. Check out existing mods and their communities! Almost everything is more fun with other people, and learning from other people will never be replaced by a cold, heartless wiki such as this one.</p> <p>If you get all that and you are still in, then let's start with the IDE set up.</p>"},{"location":"commands/","title":"Creating your first command","text":"<p>This tutorial focuses on client commands, meaning they will get run on the client. If you want to develop a server command there are more considerations to be done (like permissions, and synchronizing server state to the client).</p>"},{"location":"commands/#basic-command-class","title":"Basic command class","text":"<p>First, let's create a new class for our command. We will call it <code>CrashCommand</code> because it will crash your game. Of course, your command can do whatever you want. We need to make sure our command <code>extends CommandBase</code>.</p> <pre><code>public class CrashCommand extends CommandBase {\n\n    @Override\n    public String getCommandName() {\n        return \"crashme\"; // (1)!\n    }\n\n    @Override\n    public String getCommandUsage(ICommandSender sender) {\n        return \"\"; // (2)!\n    }\n\n    @Override\n    public void processCommand(ICommandSender sender, String[] args) throws CommandException {\n        throw new RuntimeException(\"Not yet implemented!\"); // (3)!\n    }\n\n    @Override\n    public boolean canCommandSenderUseCommand(ICommandSender sender) {\n        return true; // (4)!\n    }\n\n    @Override\n    public List&lt;String&gt; getCommandAliases() {\n        return Arrays.asList(\"dontcrashme\"); // (5)!\n    }\n}\n</code></pre> <ol> <li>This is the name of your command. You can call your command in chat with <code>/crashme</code>. You should only use numbers and letters for this name, since a lot of other characters make it impossible to call your command.</li> <li>This can be left empty. By default this is used by the vanilla <code>/help</code> command. But since we are on SkyBlock, where Hypixel uses a custom help menu that does not show client commands, there isn't really any point in filling that one out.</li> <li>We will implement the actual code in the next section</li> <li>This method simply allows anyone to call this command. Since this is a client command, \"anyone\" just means \"the local player\".</li> <li>The <code>getCommandAliases</code> method allows you to specify additional names that your command can be called by. You can just not implement this method if you want to only use the name returned by <code>getCommandName</code>.</li> </ol> <p>Warning</p> <p>When writing a client command you will need to override <code>canCommandSenderUseCommand</code>. By default this method does not generate, but without it you will get a <code>You do not have permission to use this command</code> error (since you by default do not have any permissions on a server). Just always return <code>true</code>, since the command is client side only anyway.</p>"},{"location":"commands/#registering-your-command","title":"Registering your command","text":"<p>After all this work your command still just will not run. This is because right now you just have a random Java class Forge knows nothing about. You need to register your command. You typically do this in the <code>FMLInitializationEvent</code>:</p> <pre><code>@Mod.EventHandler\npublic void init(FMLInitializationEvent event) {\n    ClientCommandHandler.instance.registerCommand(new CrashCommand());\n}\n</code></pre>"},{"location":"commands/#running-your-command","title":"Running your command","text":"<p>The <code>processCommand</code> method is run when your command is executed:</p> <pre><code>@Override\npublic void processCommand(ICommandSender sender, String[] args) throws CommandException {\n    LogManager.getLogger(\"CrashCommand\").info(\"Intentionally crashing the Game!\");\n    FMLCommonHandler.instance().exitJava(1, false);\n}\n</code></pre> <p>Info</p> <p>When using a Logger, make sure to use the <code>LogManager</code> from <code>org.apache.logging.log4j.LogManager</code>. Using the other log managers won't work.</p> <p>Info</p> <p>If you want to close the game, you need to use <code>FMLCommonHandler.instance().exitJava(exitCode, false)</code> instead of <code>System.exit()</code>. Forge disables the normal <code>System.exit()</code> calls.</p> <p>But, this way of crashing the game might be a bit too easy to accidentally run. So let's add a confirmation system. When your <code>processCommand</code> is called, you are given two arguments: the <code>sender</code> is always the current player (since this is a client command), and the <code>args</code> array gives you all the arguments you are being called with. If a player runs the command <code>/crashme foo bar</code>, args will be <code>new String[] {\"foo\", \"bar\"}</code>.</p> <pre><code>@Override\npublic void processCommand(ICommandSender sender, String[] args) throws CommandException {\n    // Be sure to check the array length before checking an argument\n    if (args.length == 1 &amp;&amp; args[0].equals(\"confirm\")) {\n        LogManager.getLogger(\"CrashCommand\").info(\"Intentionally crashing the Game!\");\n        FMLCommonHandler.instance().exitJava(1, false);\n    } else {\n        sender.addChatMessage(new ChatComponentText(\"\u00a7aAre you sure you want to crash the game? Click to confirm!\")\n                .setChatStyle(new ChatStyle()\n                    .setChatClickEvent(new ClickEvent(ClickEvent.Action.RUN_COMMAND, \"/crashme confirm\"))));\n    }\n}\n</code></pre> <p>Info</p> <p>Because <code>sender</code> is always the current player, you can also use <pre><code>Minecraft.getMinecraft().thePlayer.addChatMessage(/* ... */);\n</code></pre></p> <p>Minecraft uses <code>IChatComponent</code>s in chat (and a few other places). You can make those by calling <code>new ChatComponentText(\"\")</code>. In there you can use format codes like <code>\u00a7a</code>. If you want, you can also use <code>EnumChatFormatting.GREEN.toString()</code> instead of <code>\u00a7a</code>. You can change the chat style of a <code>ChatComponentText</code> in order to give it hover or click effects.</p> <p>Warning</p> <p>You might be tempted to open a gui from your command like this: <pre><code>@Override\npublic void processCommand(ICommandSender sender, String[] args) throws CommandException {\n    Minecraft.getMinecraft().displayGuiScreen(new MyGuiScreen());\n}\n</code></pre> This will not work, since your command gets executed from the chat gui and sending a chat line schedules the chat gui to be closed in the same tick (accidentally closing your gui instead).</p> <p>In order to make this work, you need to instead wait a tick and then open your gui. You can do this by having a tick event handler in your main mod class like this:  <pre><code>// In your main mod class\npublic static GuiScreen screenToOpenNextTick = null;\n\n@SubscribeEvent\npublic void onTick(TickEvent.ClientTickEvent event) {\n    if (event.phase == TickEvent.Phase.END) return;\n    if (screenToOpenNextTick != null) {\n        Minecraft.getMinecraft().displayGuiScreen(screenToOpenNextTick);\n        screenToOpenNextTick = null;\n    }\n}\n\n// In your command class:\n@Override\npublic void processCommand(ICommandSender sender, String[] args) throws CommandException {\n    ExampleMod.screenToOpenNextTick = new MyGuiScreen();\n}\n</code></pre></p> <p>See Events for more info on how to set up event handlers.</p>"},{"location":"commands/#tab-completion","title":"Tab Completion","text":"<p>Minecraft allows you to press tab to auto complete arguments for commands. Your command will already be tab completable, but in order for this to also work with the arguments of your command, you need to override <code>addTabCompletionOptions</code>:</p> <pre><code>@Override\npublic void processCommand(ICommandSender sender, String[] args) throws CommandException {\n    if (args.length == 0) {\n        sender.addChatMessage(new ChatComponentText(\"\u00a7cPlease use an argument\"));\n    } else if (args[0].equals(\"weather\")) {\n        sender.addChatMessage(new ChatComponentText(\"\u00a7bCurrent Weather: \" +\n                (Minecraft.getMinecraft().theWorld.isRaining() ? \"\u00a77Rainy!\" : \"\u00a7eSunny!\")));\n    } else if (args[0].equals(\"coinflip\")) {\n        sender.addChatMessage(new ChatComponentText(\"\u00a7bCoinflip: \" +\n                (ThreadLocalRandom.current().nextBoolean() ? \"\u00a7eHeads\" : \"\u00a7eTails\")));\n    } else {\n        sender.addChatMessage(new ChatComponentText(\"\u00a7cUnknown subcommand\"));\n    }\n}\n\n@Override\npublic List&lt;String&gt; addTabCompletionOptions(ICommandSender sender, String[] args, BlockPos pos) {\n    if (args.length == 1) // (1)!\n        return getListOfStringsMatchingLastWord(args, \"weather\", \"coinflip\"); // (2)!\n    return Arrays.asList();\n}\n</code></pre> <ol> <li>The args array contains all the arguments. The last argument is the one you should autocomplete. It contains the partial argument, or an empty string. Make sure to check the length of the array, so you know which argument you are autocompleting.</li> <li>The <code>getListOfStringsMatchingLastWord</code> function automatically filters your autocompletion results based on the options you give it. The first argument is the <code>args</code> array, the second argument is either a <code>List&lt;String&gt;</code> or a vararg of <code>String</code>s</li> </ol>"},{"location":"events/","title":"Events in Forge","text":"<p>Forge uses events to allow mods to communicate with Minecraft and each other. Most of the events you will need to use come from Forge, but you can also create your own events if you need more.</p>"},{"location":"events/#subscribing-to-events","title":"Subscribing to events","text":"<p>If you are interested in an event you need to create an event handler. For this first create a method that has the <code>@SubscribeEvent</code> annotation, is <code>public</code>, return <code>void</code> and takes an event as an argument. The type of the event argument is what decides which events your method receives. You can also only have one argument on an event handler.</p> <pre><code>public class MyEventHandlerClass {\n    int chatCount = 0;\n    @SubscribeEvent //(1)!\n    public void onChat(ClientChatReceivedEvent event) { //(2)!\n        chatCount++;\n        System.out.println(\"Chats received total: \" + chatCount);\n    }\n}\n</code></pre> <ol> <li>This annotation informs Forge that your method is an event handler</li> <li>The method parameter tells Forge which events this event handler listens to</li> </ol> <p>This on it's own will not do anything yet. You must also register the event handler. To do that you register it on the corresponding event bus. For almost everything you will do, you need the <code>MinecraftForge.EVENT_BUS</code> (yes, even your own custom events should use this event bus). The best place to do this is in one of your <code>FML*InitializationEvent</code>s.</p> <pre><code>@Mod(modid = \"examplemod\", useMetadata = true)\npublic class ExampleMod {\n    @Mod.EventHandler\n    public void init(FMLInitializationEvent event) {\n        MinecraftForge.EVENT_BUS.register(new MyEventHandlerClass());\n        MinecraftForge.EVENT_BUS.register(this);\n    }\n}\n</code></pre>"},{"location":"events/#cancelling-events","title":"Cancelling Events","text":"<p>Forge Events can be cancelled. What exactly that means depends on the event, but it usually stops the action the event indicates from happening.</p> <pre><code>@SubscribeEvent\npublic void onChat(ClientChatReceivedEvent event) {\n    // No more talking about cheese\n    if (event.message.getFormattedText().contains(\"cheese\"))\n        event.setCanceled(true); // (1)!\n}\n</code></pre> <ol> <li>Cancel the event</li> </ol> <p>Not all events can be cancelled. Check the event class in the decompilation for the <code>@Cancellable</code> annotation.</p> <p>If an event is cancelled, it not only changes what Minecraft's code does with the event, but also prevents all other event handlers that come afterwards from handling the event. If you want your event handler to even receive cancelled events, use <code>receiveCanceled = true</code>:</p> <pre><code>@SubscribeEvent(receiveCanceled = true) // (1)!\npublic void onChat(ClientChatReceivedEvent event) {\n    event.setCanceled(false); // (2)!\n}\n</code></pre> <ol> <li>Make sure our event handler receives cancelled events</li> <li>Uncancel the event. This means the event will be handled by Minecrafts code normally again and you will see the chat.</li> </ol>"},{"location":"events/#custom-events","title":"Custom Events","text":"<p>Note</p> <p>This is an advanced topic that most mod developers don't need to worry about.</p> <p>Forge also allows you to create custom events. Each event needs to have it's own class extending <code>Event</code> (transitively or not). (Make sure you extend <code>net.minecraftforge.fml.common.eventhandler.Event</code>, not any other event class).</p> <pre><code>@Cancelable // (1)!\npublic class CheeseEvent extends Event { // (2)!\n    public final int totalCheeseCount;\n\n    public CheeseEvent(int totalCheeseCount) {\n        this.totalCheeseCount = totalCheeseCount;\n    }\n}\n</code></pre> <ol> <li>If you want your event to be cancellable, you need this annotation. Remove it for an uncancellable event.</li> <li>Extend the Forge <code>Event</code> class. The rest of your class is just normal Java.</li> </ol> <p>That's it, you are done. You have a custom event!</p> <p>I'm kidding of course. The next step is actually using your event. For now, let's put our own custom event inside the forge chat event (you will later learn how to use mixins to create even more events):</p> <pre><code>int cheeseCount = 0;\n\n@SubscribeEvent\npublic void onChat(ClientChatReceivedEvent event) {\n    if (event.message.getFormattedText().contains(\"cheese\")) {\n        CheeseEvent cheeseEvent = new CheeseEvent(++cheeseCount); // (1)!\n        MinecraftForge.EVENT_BUS.post(cheeseEvent); // (2)!\n    }\n}\n</code></pre> <ol> <li>Creates a new <code>CheeseEvent</code> instance. This is just a normal java object construction, which does not interact with Forge at all.</li> <li>Send our <code>CheeseEvent</code> to be sent to all event handlers by Forge.</li> </ol> <p>And now we are done, unless you want your event to be cancellable. For cancellable events we also need to add code to handle cancelled events. What that cancelling does is up to you, but in our example let's just cancel the original chat message event (hiding that chat message):</p> <pre><code>@SubscribeEvent\npublic void onChat(ClientChatReceivedEvent event) {\n    if (event.message.getFormattedText().contains(\"cheese\")) {\n        CheeseEvent cheeseEvent = new CheeseEvent(++cheeseCount);\n        MinecraftForge.EVENT_BUS.post(cheeseEvent);\n        if (cheeseEvent.isCanceled()) {\n            event.setCanceled(true);\n        }\n    }\n}\n</code></pre> <p>You can now subscribe to your custom event like you would to any other event:</p> <pre><code>@SubscribeEvent\npublic void onCheese(CheeseEvent event) {\n    if (event.totalCheeseCount &gt; 10) {\n        // Only 10 cheese messages are allowed per restart\n        event.setCanceled(true);\n    }\n}\n</code></pre>"},{"location":"ide-setup/","title":"Setting up","text":"<p>This is a slightly rewritten version of SBMW's Getting started article. That one was also written by me, and contains roughly the same info.</p> <p>Note</p> <p>Downloads in this tutorial are provided as a convenience, if you know what you are doing you can find these downloads somewhere else (in a package manager like chocolatey, pacman or sdkman). If you decide to go that route, please make sure that you download the exact same Software and not something similar.</p>"},{"location":"ide-setup/#setting-up-a-java-development-environment","title":"Setting up a Java Development Environment","text":"<p>Minecraft mods are written in Java and as such you will need a Java Development Setup. You will need both</p> <ul> <li>A Java JDK (not JRE) for version 17</li> <li>A Java JDK (not JRE) for version 8</li> </ul>"},{"location":"ide-setup/#setting-up-an-integrated-development-environment","title":"Setting up an Integrated Development Environment","text":"<p>There is pretty much only one IDE for mod development, which is IntelliJ. In theory it is also possible to code in VSCode, Vim or Eclipse, but doing so is difficult to set up and not recommended. Even if you are already familiar with one of these IDEs, switching to IntelliJ is pretty much mandatory.</p> <p>IntelliJ has a free community edition, as well as a paid ultimate edition, both available for download here.</p>"},{"location":"ide-setup/#setting-up-github","title":"Setting up GitHub","text":"<p>Although not strictly neccessary, it is recommended that you create a GitHub Account. This tutorial will assume you have one. If you do not have a GitHub Account you might need to find some more manual work arounds for some things.</p>"},{"location":"ide-setup/#deciding-on-a-project","title":"Deciding on a Project","text":""},{"location":"ide-setup/#contributing-to-an-existing-project","title":"Contributing to an existing Project","text":"<p>If you want to contribute to an existing project, find that project on GitHub and Discord. You can usually find both linked on their page on the SkyBlock Mod Wiki. You can typically ask around in the Discord for help, which will help you to get up to speed with whether they will accept a feature you are planning to contribute. Once all of that is cleared, you can create a Fork on GitHub. You will then do everything with the forked repository as you would do with your own repository, and once you are done create a pull request in the original repository you are planning to contribute to.</p>"},{"location":"ide-setup/#creating-a-new-project","title":"Creating a new Project","text":"<p>Go to Forge1.8.9Template. Click on \"Use this template\" and \"Create a new Repository\". Find a good name for your mod. If you want to code your mod in Kotlin or make a 1.12 mod you will need to tick \"Include all branches\". Don't worry about it too much, you can change this later with a little bit of effort.</p> <p>Warning</p> <p>Do not clone the template repository directly (or download a zip of the template repository). When using the \"Use this template\" option on GitHub, there is some additional processing being done to insure your repository is fully set up.</p> <p>If you must you can also manually use the <code>make-my-own.sh</code> script, but only on Linux, and there are no guarantees for it to work.</p>"},{"location":"ide-setup/#setting-up-your-ide","title":"Setting up your IDE","text":"<p>IntelliJ has a built in option for cloning a project. Chose \"New\" then \"Project from Version Control\". Log into GitHub and clone the project.</p> <p>Once the project is done cloning, you need to head into your  gradle settings (the elephant on the right of your workspace, then click on the cogwheel) and change the gradle JVM to be a version 17 JDK.</p> <p>Next go into your Project Settings (Ctrl+Alt+Shift+S) and set the Project SDK to be a version 8 JDK.</p> <p>Finally click on the reload button in the gradle tab on the right from earlier.</p> <p>You should now have generated a Run Config in IntelliJ. You can find those next to the . If you can't find it, check the <code>.idea/runConfigurations</code> folder. If you can find a file there, you just need to restart IntelliJ.</p> <p>Always use these run configs instead the <code>runClient</code> task in the gradle tab. The gradle task does not work.</p>"},{"location":"ide-setup/#common-issues","title":"Common Issues","text":""},{"location":"ide-setup/#no-matching-variant-of-devarchitecturyarchitectury-pack200013-was-found","title":"No matching variant of dev.architectury:architectury-pack200:0.1.3 was found.","text":"<p>This error indicates that your Java Version does not support architectury. Fix this by setting your gradle JDK to 17</p>"},{"location":"screens/","title":"Screens and You","text":"<p>Creating a custom screen manually is quite a big effort. Instead you can consider using an existing GUI library:</p> <ul> <li>MoulConfig is a config library with some features for custom GUIs based on NEUs GUIs.</li> <li>Elementa is a gui library made by sk1er. It mainly targets Kotlin, an alternative programming language to Java, but can in theory also be used from Java.</li> <li>Vigilance is fully automated Elementa for config GUIs only.</li> <li>OneConfig is a config library made by Polyfrost.</li> <li>or just do it yourself. Writing a gui is not the easiest thing in modding, but nothing allows you more customization.</li> </ul>"},{"location":"screens/#basic-scaffold","title":"Basic Scaffold","text":"<p>A basic gui screen has 3 methods:</p> <pre><code>public class MyGuiScreen extends GuiScreen {\n    @Override\n    public void drawScreen(int mouseX, int mouseY, float partialTicks) {\n        drawDefaultBackground();\n        super.drawScreen(mouseX, mouseY, partialTicks);\n    }\n\n    @Override\n    protected void keyTyped(char typedChar, int keyCode) throws IOException {\n        super.keyTyped(typedChar, keyCode);\n    }\n\n    @Override\n    protected void mouseClicked(int mouseX, int mouseY, int mouseButton) throws IOException {\n        super.mouseClicked(mouseX, mouseY, mouseButton);\n    }\n}\n</code></pre> <p><code>drawScreen</code> is called every frame and is used to render things onto the screen. Note that you first call <code>drawDefaultBackground()</code> (which tints the background dark) and then call <code>super.drawScreen()</code> (which renders widgets on your screen).</p> <p><code>keyTyped</code> is called whenever a key is pressed. You can check <code>typedChar</code> to see the character they typed, or you can check <code>keyCode</code> if you want to know the key they pressed. For example a key like F7 would not have a <code>typedChar</code>, but would have the <code>keyCode == Keyboard.KEY_F7</code>. We also call <code>super.keyTyped()</code> here so that the standard Esc to close works.</p> <p><code>mouseClicked</code> is called whenever the mouse is clicked in your screen. The <code>mouseButton</code> sadly doesn't have a vanilla class with names for them like <code>Keyboard</code>, but you can use these constants instead: </p> <pre><code>public static final int MOUSE_LEFT = 0;\npublic static final int MOUSE_RIGHT = 1;\npublic static final int MOUSE_MIDDLE = 2;\npublic static final int MOUSE_BACKWARD = 3;\npublic static final int MOUSE_FORWARD = 4;\n</code></pre> <p>You can also always access the <code>width</code> and <code>height</code> fields to get the screen width and height to layout your components.</p>"},{"location":"screens/#adding-buttons","title":"Adding buttons","text":"<p>Vanilla has a system for buttons already built in, which i am using for a simple color selector:</p> <pre><code>int lastClickedButton = 0;\n\n@Override\npublic void initGui() {\n    super.initGui();\n    // Add buttons to the gui list during gui initialization\n    this.buttonList.add(new GuiButton(0, width / 2 - 55, height / 2 - 10, 30, 20, \"\u00a7cRED\"));\n    this.buttonList.add(new GuiButton(1, width / 2 - 15, height / 2 - 10, 30, 20, \"\u00a79BLUE\"));\n    this.buttonList.add(new GuiButton(2, width / 2 + 25, height / 2 - 10, 30, 20, \"\u00a72GREEN\"));\n}\n\n@Override\nprotected void actionPerformed(GuiButton button) throws IOException {\n    // When a button is clicked saved that last id (or do something else based on the id)\n    // You could change a setting here for example\n    lastClickedButton = button.id;\n}\n\n@Override\npublic void drawScreen(int mouseX, int mouseY, float partialTicks) {\n    // Draw the background tint\n    drawDefaultBackground();\n\n    // Find the last selected color\n    int color = 0;\n    if (lastClickedButton == 0) {\n        color = 0xFFFF0000;\n    } else if (lastClickedButton == 1) {\n        color = 0xFF0000FF;\n    } else if (lastClickedButton == 2) {\n        color = 0xFF00FF00;\n    }\n\n    // Draw a colorful rectangle\n    drawGradientRect(width / 2 - 65, height / 2 - 20, width / 2 + 65, height / 2 + 20, color, color);\n\n    // Draw buttons\n    super.drawScreen(mouseX, mouseY, partialTicks);\n}\n</code></pre> <p></p>"},{"location":"screens/#rendering-text-and-images","title":"Rendering text and images","text":"<p>Instead of using built in buttons and basic rectangles, you can also render more complex things.</p>"},{"location":"screens/#rendering-text","title":"Rendering text","text":"<p>You can easily use Minecrafts built in font renderer to render any text you like.</p> <pre><code>@Override\npublic void drawScreen(int mouseX, int mouseY, float partialTicks) {\n    // Draw tinted background\n    drawDefaultBackground();\n\n    // Draw an outline rectangle\n    drawGradientRect(width / 2 - 100, height / 2 - 20, width / 2 + 100, height / 2 + 20, 0xFF808080, 0xFF808080);\n\n    FontRenderer fr = Minecraft.getMinecraft().fontRendererObj;\n    String text = \"Hello, World!\";\n    int textWidth = fr.getStringWidth(text);\n\n    // Draw a string left aligned\n    fr.drawString(text, width / 2 - 95, height / 2 - 18, -1);\n\n    // Draw a string center aligned\n    fr.drawString(text, width / 2 - textWidth / 2, height / 2 - 8, -1);\n\n    // Draw a string right aligned\n    fr.drawString(text, width / 2 + 95 - textWidth, height / 2 + 2, -1);\n}\n</code></pre> <p></p>"},{"location":"screens/#rendering-images","title":"Rendering images","text":"<p>Images in Minecraft are rendered from the assets folder. In your project, you should have a folder called <code>src/main/resources</code>. In that folder you create two more folders called <code>assets/&lt;yourmodidhere&gt;/</code>. That is your asset root. In here you can put any file you want and load it into Minecraft. You probably want your textures to be in a folder like <code>textures/gui</code> inside your asset root however (<code>src/main/resources/assets/&lt;yourmodidhere&gt;/textures/gui/mytexture.png</code>).</p> <p>For images you probably want to use png files, since Minecraft supports these out of the box, unlike most other image formats.</p> <p>For this tutorial you can use this background.</p> <pre><code>@Override\npublic void drawScreen(int mouseX, int mouseY, float partialTicks) {\n    // Draw tinted background\n    drawDefaultBackground();\n\n    Minecraft minecraft = Minecraft.getMinecraft();\n\n    // First we need to bind the texture\n    minecraft.getTextureManager().bindTexture(new ResourceLocation(\"examplemod\"/* or your modid */, \"textures/gui/background.png\"));\n\n    // Render from your texture.\n    drawModalRectWithCustomSizedTexture(\n            width / 2 - 100, height / 2 - 20, // (1)!\n            0, 0,  // (2)!\n            200, 40, // (3)!\n            200, 40 // (4)!\n    );\n\n    FontRenderer fr = minecraft.fontRendererObj;\n    String text = \"Hello, World!\";\n    int textWidth = fr.getStringWidth(text);\n\n    // Draw a string left aligned\n    fr.drawString(text, width / 2 - 95, height / 2 - 15, 0xFF000000);\n\n    // Draw a string center aligned\n    fr.drawString(text, width / 2 - textWidth / 2, height / 2 - 5, 0xFF000000);\n\n    // Draw a string right aligned\n    fr.drawString(text, width / 2 + 95 - textWidth, height / 2 + 5, 0xFF000000);\n}\n</code></pre> <ol> <li>This is the top left position of where your texture should be rendered.</li> <li>This is the starting u and v of your texture. If you don't have any custom UVs, you can just use <code>(0, 0)</code></li> <li>This is the size on the screen of what you want to render. If you don't use custom UVs, this needs to match your texture size. If you want to scale your texture, check out Matrix Transformations or <code>drawScaledCustomSizeModalRect</code> (which is a bit more complicated).</li> <li>This is the size of your texture, you need to hardcode this here, since texture packs can upload lower and higher resolution versions of your texture, and Minecraft needs to figure out how to scale the texture.</li> </ol>"},{"location":"screens/#uvs","title":"UVs","text":"<p>Texture rendering in OpenGL (which is what Minecraft uses) uses UVs for reading from a texture. Instead of always rendering an entire texture, you can render only parts of a texture. This allows you to reuse a texture, without rebinding it, which can be beneficial for performance. For now I wouldn't worry about optimizing like that too much, but you'll still need to use UVs anyway.</p> <p>The U component goes along the x axis of the image and starts with 0 at the left and ends with 1 at the right. The V component goes along the y axis of the image and starts with 0 at the top and ends with 1 at the bottom. This is specific to OpenGL, other game engines might have different UV coordinate spaces.</p> <p></p> <p>To calculate the actual uv you want to start with in game, just divide the pixel coordinate by the texture size: </p> <pre><code>float u = 16 / 64; // start at x pixel coordinate 16 with a 64 wide image\n</code></pre>"},{"location":"screens/#glstatemanager","title":"GlStateManager","text":"<p><code>GlStateManager</code> is a class that changes the behaviour of all other rendering calls.</p>"},{"location":"screens/#transformations","title":"Transformations","text":"<p><code>GlStateManager</code> has a so called \"matrix stack\" which stores a set of transformations that get applied to all render calls you do. Only the top layer of the matrix stack affects your render calls.</p>"},{"location":"screens/#translations","title":"Translations","text":"<p>Translations move things around. <code>translate(10, 0, 0)</code> would cause all future render calls to instead render 10 pixels to the right. You may notice that <code>translate</code> takes 3 arguments. This is because the <code>z</code> direction is also translated. This is useful in 3D, but can be used in 2D GUI rendering as well to move things in front of other things. In a GUI a greater z value means that something renders in front of something that has a lower z.</p> <p>You can use this to render a tooltip for example. By default later rendering calls in your method would render on top of the tooltip, but if you first translate to a high z value and then back to normal after your tooltip rendering, the other method calls won't render on top of the tooltip.</p>"},{"location":"screens/#scaling","title":"Scaling","text":"<p>Scalings, well, scale things. This means a <code>scale(2, 2, 1)</code> call would render everything after twice as big. But you need to be careful. Everything is twice as big, including the coordinates at which you render.</p> <pre><code>GlStateManager.scale(2, 2, 1);\n\nfontRenderer.drawString(\"Hello, World!\", 10, 10, -1);\n</code></pre> <p>This would normally render at <code>(10, 10)</code>. But since everything is scaled two times, it actually renders at <code>(20, 20)</code> and twice as big. To circumvent that you can instead first translate, then scale, and then render at <code>(0, 0)</code>.</p> <pre><code>GlStateManager.translate(10, 10, 0);\nGlStateManager.scale(2, 2, 1);\n\nfontRenderer.drawString(\"Hello, World!\", 0, 0, -1);\n</code></pre> <p>Alternatively you can do the math and divide all coordinates by your current scale factor.</p> <p>Warning</p> <p>Please always use <code>1</code> as a scale factor for the z direction. If you do not do this, a lot of rendering calls will break and parts of your GUI might just not render at all or in the wrong order. You can use other non-zero scale factors for z like <code>2</code> sometimes, but in almost all cases that is the wrong behaviour and you should instead use the scale factor <code>1</code>.</p>"},{"location":"screens/#stack-manipulation","title":"Stack Manipulation","text":"<p>I mentioned earlier that the GlStateManager has a matrix stack. Your transformations and render calls only ever use the topmost matrix on that stack. Those other layers have a purpose however. Since you always want to hand back the GlStateManager in the same state you got it (otherwise all of Minecraft renders 10 pixels to the side. oops) you might be tempted to manually undo all your <code>translate</code> and <code>scale</code> calls. While this is doable, a much easier way is to instead use the matrix stack.</p> <p>You can push a new matrix to the stack by using <code>pushMatrix</code>. This copies the current top matrix (with all the transformations applied by earlier code) and makes that new matrix the top matrix. Then after your code is done you can just call <code>popMatrix</code> and that top matrix is discarded and the old matrix with all the old transformations is used for the rest of the code. Just put your rendering and transformation calls inside of those two method calls and all should work out. (Of course inside of the <code>pushMatrix</code> <code>popMatrix</code> environment transformations still only apply to code after the transformation is applied.)</p> <pre><code>GlStateManager.pushMatrix();\nGlStateManager.translate(Math.random() * 100, Math.random() * -30, 200000);\n// more wacky transformation calls here\n// then comes your rendering code\nfr.drawString(\"Hi\", 0, 0, -1);\nGlStateManager.popMatrix();\n// And here everything is normal again\n</code></pre>"},{"location":"screens/#rotation","title":"Rotation","text":"<p>Rarely you might also want to rotate things. Rotation works a bit differently than how you might expect it. A common way of doing rotation is with euler angles, so basically just rotation around x, y and z as 3 values. This has a lot of drawbacks, but is quite easy to visualize and is commonly used in 3D modeling software.</p> <p>Minecraft instead uses rotations around a vector. This means you choose the axis you want to rotate around, and then you choose the angle. If you want to rotate around x, y and z after one another, you need to make 3 rotate calls this way.</p> <p>Remember, like with the other transformations, the Z direction points out of the screen towards the \"front\".</p> <pre><code>GlStateManager.pushMatrix();\nGlStateManager.translate(width / 2, height / 2 - 5 + fr.FONT_HEIGHT / 2, 0);\nGlStateManager.rotate((float) ((System.currentTimeMillis() / 200.0) % (360)), 0, 0, 1);\nfr.drawString(text, -textWidth / 2, -fr.FONT_HEIGHT / 2, 0xFF000000);\nGlStateManager.popMatrix();\n</code></pre>"},{"location":"screens/#attributes","title":"Attributes","text":"<p>In addition to transformations you can also change \"attributes\" about the render calls. These can be occasionally useful, but are a bit more complicated.</p>"},{"location":"screens/#stack-manipulation_1","title":"Stack Manipulation","text":"<p>Like the matrix stack for  transformations there is also an \"attribute stack\" for attributes. That one is severly broken in Minecraft, however. There is a bug in <code>GlStateManager</code> that means that if you set an attribute using <code>GlStateManager</code> inside of a <code>pushAttrib</code>-<code>popAttrib</code> block, you sometimes cannot set that attribute again. This means when inside of such a block you cannot call Minecrafts wrappers in <code>GlStateManager</code> and you need to instead call OpenGL directly. I recommend against using this however, since vanilla code you call might still use <code>GlStateManager</code>, therefore breaking attributes until the next frame. Use these two methods very carefully, if at all.</p>"},{"location":"screens/#color","title":"Color","text":"<p><code>GlStateManager.color</code> is probably the easiest example of an attribute. You can use it to tint all your future render calls, including textures and text. You probably already set a color using <code>fr.drawString</code>, since that has a color argument, which in turn just calls <code>GlStateManager.color</code> after several layers of abstractions. If you want everything back to normal, just set the color to <code>color(1, 1, 1, 1)</code>. </p>"},{"location":"screens/#depth","title":"Depth","text":"<p><code>enableDepth</code> and <code>disableDepth</code> turn on and off depth testing. Meaning that the z value ignored and things with a high z value might render behind things with a low z value. Only the render order matters now, instead of the z value.</p> <p>On top of that you can use <code>depthFunc</code> along with <code>GL11.GL_LESS</code>, <code>GL11.GL_LEQUAL</code>, <code>GL11.GL_GREATER</code>, <code>GL_ALWAYS</code> (which is equivalent to <code>disableDepth</code>) etc, to decide in which direction the depth test functions.</p>"},{"location":"screens/#blending","title":"Blending","text":"<p>Blending specifies how transparent images render on top of each other. Again you can <code>enableBlend</code> and <code>disableBlend</code>, as well as specify the function to use to blend two images. Again, you can use values from <code>GL11</code> like <code>GL11.GL_ONE_MINUS_SRC_ALPHA</code>, <code>GL11.GL_ONE_MINUS_DST_ALPHA</code>, <code>GL11.GL_SRC_ALPHA</code> and so on with <code>blendFunc</code> or <code>tryBlendFuncSeparate</code>.</p>"},{"location":"screens/#and-many-more","title":"And many more","text":"<p>There are a ton of attributes, some of them more useful, some of them less. Most of them map to regular OpenGL attributes, so you can always look up OpenGL tutorials on how to use them. Or check out other mods or vanilla code to see them in action. Just remember to always reset attributes to how you got them.</p>"},{"location":"screens/#going-beyond","title":"Going beyond","text":"<p>Minecraft has a few built in methods for drawing that I showed you in here. But Minecraft has many more, for rendering Items in UIs, and other things, but these basics should get you started. Be sure to always check out vanilla code for example usages. And if vanilla is missing something you want, you can always call the OpenGL primitives that Minecraft itself calls.</p>"},{"location":"mixins/","title":"Mixins","text":"<p>Mixins allow you to change Minecraft code. This is massively powerful, but you need to be very careful when using them, especially when considering if you want to integrate well with other mods.</p> <p>Info</p> <p>The MinecraftDev plugin is pretty much non negotiable when coding Mixins. It enables auto completion, shows errors when your mixins are wrong in your IDE and allows you to directly navigate to the code you are changing.</p> <p>It also has some other functions that allow for easier Minecraft development, but most of that functionality is aimed at higher Minecraft versions.</p> <p>Please forgive the the nonsensical examples. I try to make the examples as simple as possible. Check out some open source mods to check out some real world mixins.</p>"},{"location":"mixins/#layout","title":"Layout","text":"<p>Mixins need to be in their own package. You should have a dedicated mixin package in the template already. You can have multiple subpackages, but your normal code and your Mixin code need to be separate. This is because Mixins are instructions for how to change the program, rather than actual program code itself. Mixins also need to be registered in your <code>mixin.example.json</code>. In there you only need to put the class name, not including the mixin package. Mixins also need to be written in Java, not in Kotlin.</p> <pre><code>{\n  \"package\": \"${mixinGroup}\",\n  \"refmap\": \"mixins.${modid}.refmap.json\",\n  \"minVersion\": \"0.7\",\n  \"compatibilityLevel\": \"JAVA_8\",\n  \"mixins\": [\n        \"MixinGuiMainMenu\",\n        \"subpackage.MixinSomeOtherClass\"\n  ]\n}\n</code></pre> <p>You can also have multiple mixins for the same Minecraft class.</p>"},{"location":"mixins/#mixin-use-cases","title":"Mixin Use Cases","text":"<p>I recommend you start learning with accessor mixins, since those are the easiest, and go down the list from there.</p> <ul> <li>Accessors</li> <li>Adding Fields and Methods</li> <li>Simple Injects</li> </ul>"},{"location":"mixins/#compatibility","title":"Compatibility","text":""},{"location":"mixins/#modid-postfix","title":"Modid postfix","text":"<p>In order for your mod to be compatible with other mods it is highly recommend (if not borderline mandatory) to prefix or postfix all of your methods with your modid:</p> <pre><code>public void someMixinMethod_mymodid() {}\n// or\npublic void someMixinMethod$mymodid() {}\n</code></pre> <p>There are some exceptions for <code>@Inject</code>s, but in general it doesn't hurt to just add the postfix.</p>"},{"location":"mixins/#non-destructive-mixins","title":"Non destructive mixins","text":"<p>When mixing into a class you would generally want that if another mod the exact same mixin, that both of your mixins would work. Especially if your mixin only works sometimes.</p> <p>I.e. if you want a mixin to color mobs, and your mod decides not to color a mob, another mod should be able to use the exact same mixin (just in their mod) to color those mobs.</p> <p>There are some general ground rules for achieving this behaviour: </p> <ul> <li>Only use <code>cir.setReturnValue()</code> or <code>ci.cancel()</code> if your mod decides to act on something. The default action should be to pass through to the next mixin or vanilla by doing nothing.</li> <li>Don't use <code>@Redirect</code>. Only one mixin can ever use a <code>@Redirect</code> on the same call. Only one redirect will ever work, even if your mod does nothing different with a given method call.</li> <li>Don't use <code>@Overwrite</code> (and don't overwrite without the annotation either, lol). Only one overwrite will ever work, even if your mod does nothing different with a given method call.</li> </ul> <p>Of course you will have to break those rules from time to time. But before you do, think twice if you really need to. And if you do, maybe consider exposing some sort of API for other mods to hook into your code?</p>"},{"location":"mixins/#troubleshooting","title":"Troubleshooting","text":"<p>The first step in troubleshooting mixins is to enable <code>-Dmixin.debug=true</code> in your run configurations jvm arguments. This will print out all the Mixins as they are applied and show you exactly what is wrong with each mixin, and why it wasn't applied.</p> <p>Another common issue is to forget to register a mixin in the <code>mixins.modid.json</code></p> <p>You can also get exceptions when trying to load a mixin class directly. Accessing any mixin class except for an accessor from non mixin code will crash your game. If you want to call a method inside a mixin, have that mixin implement an interface instead.</p>"},{"location":"mixins/accessors/","title":"Accessor Mixins","text":"<p>a/k/a Reverse Patch</p> <p>Let's start with the easiest form of Mixins \u2014 Accessors. Accessors allow you to access functions that are otherwise private in a Minecraft class. You can also do that using reflection, but you might notice that your reflection call will not easily work in both devenv and a live env. This is because the method names are different in a devenv compared to a normal Forge installation. You can still specify both names and just look through all the names using reflection, but Accessor Mixins are a lot easier to use, with less accidental pitfalls, and better performance.</p> <pre><code>// This Mixin targets the Minecraft class\n@Mixin(Minecraft.class)\npublic interface AccessorMinecraft {\n\n    // Getter for the field theIntegratedServer\n    // Notice the _mymodid at the end.\n    @Accessor(\"theIntegratedServer\")\n    IntegratedServer getIntegratedServe_mymodid();\n\n    // Setter for serverPort\n    @Accessor(\"serverPort\")\n    void setServerPort_mymodid(int port);\n\n    // Invoker for rightClickMouse.\n    @Invoker(\"rightClickMouse\")\n    void rightClickMouse_mymodid();\n}\n</code></pre> <p>First, notice that we need to use an <code>interface</code>. Most mixins are <code>class</code>es. Accessors are the exception, since we don't want to actually put any code into the <code>Minecraft</code> class. Accessor mixins can also not be mixed with other mixin styles, but since you should have multiple mixins even for the same class for different things anyway, this shouldn't be an issue.</p> <p>Next we put the <code>@Mixin</code> annotation on our Accessor to let it known which class we want to inject into.</p> <p>Then for a field we use the <code>@Accessor</code> annotation, with the name of the field we want to access. Please give all your mixin methods a <code>_mymodid</code> indicator, to avoid name collissions with other mods.</p> <p>For a setter, the method returns <code>void</code> and takes one argument of the type of the field you are targetting. For a getter, the method returns the type of the field you are targeting and takes no arguments.</p> <p>For an method invoker, you copy the method signature you want to call, but rename it to something unique with a <code>_mymodid</code> postfix.</p> <p>Now if you want to use those methods, you can simply cast any instance of your targeted class to your accessor mixin class:</p> <pre><code>Minecraft mc = Minecraft.getMinecraft();\nAccessorMinecraft accessorMc = (AccessorMinecraft) mc;\naccessorMc.rightClickMouse_mymodid();\n</code></pre> <p>If you get a class cast exception here, it means your mixin was not applied. This can happen if you forgot to register your mixin, or if your mixin contains errors.</p>"},{"location":"mixins/adding-fields/","title":"Adding new fields and methods","text":"<p>The next step up is injecting fields and methods into a class. This allows you to store additional state in objects, or can serve as an alternative to accessors for more complex operations that need to access private state of a class.</p> <pre><code>@Mixin(EntityArmorStand.class)\npublic class InjectCustomField {\n    Color colorOverride_mymodid = Color.RED;\n\n    public void setColorOverride_mymodid(Color color) {\n        colorOverride_mymodid = color;\n    }\n\n    public Color getColorOverride_mymodid() {\n        return colorOverride_mymodid;\n    }\n}\n</code></pre> <p>This mixin is a <code>class</code>, like all mixin (except for accessors) are. You can make the class abstract if you want. </p> <p>First we add a new field (of course with modid postfix) into every armor stand.</p> <p>Then we also add a getter and a setter method for that field.</p> <p>Right now we run into a problem. We can't access mixin <code>class</code>es directly, so we cannot simply cast the <code>EntityArmorStand</code> into a <code>InjectCustomField</code>. Instead we create an interface (inside of our regular code, not inside of the mixin package) and implement that interface in our mixin class. You can also implement other interfaces this way, not just your own.</p> <pre><code>// Inside our regular code. Not in the mixin package\npublic interface ColorFieldAccessor {\n    void setColorOverride_mymodid(Color color);\n    Color getColorOverride_mymodid();\n}\n\n// And the updated mixin\n@Mixin(EntityArmorStand.class)\npublic class InjectCustomField implement ColorFieldAccessor {\n    Color colorOverride_mymodid;\n\n    @Override\n    public void setColorOverride_mymodid(Color color) {\n        colorOverride_mymodid = color;\n    }\n\n    @Override\n    public Color getColorOverride_mymodid() {\n        return colorOverride_mymodid;\n    }\n}\n</code></pre> <p>Now we can just cast any instance of <code>EntityArmorStand</code> to <code>ColorFieldAccessor</code>:</p> <pre><code>public static Color getColorOverrideForArmorStand(EntityArmorStand armorStand) {\n    return ((ColorFieldAccessor) armorStand).getColorOverride_mymodid();\n}\n</code></pre>"},{"location":"mixins/advanced-injects/","title":"Advanced Injects","text":"<p>So you wanna learn how to really use Injects? It is gonna be a tough road, and I won't lead you all the way there (mostly because eventually there are diminishing returns on a tutorial like this), but eventually most SkyBlock devs fall down the rabbit hole.</p> <p>This will be pretty dry compared to the other mixin tutorials, so feel free to skip reading this and just use this as a glossary.</p>"},{"location":"mixins/advanced-injects/#remapping","title":"Remapping","text":"<p>Let's start with names. Names are important. If you call a method with the wrong name, You get a crash at best, and at worse you cause undefined behavior. But, most methods go by unpronounceable names like <code>v</code> or <code>method_12934</code>. This is because Mojang obfuscated Minecraft, replacing every class name, every method name, etc. with a randomly generated short name to prevent people from reverse engineering it (which has the nice side effect of bit of a smaller binary). Now if we develop mods, we don't want to work with names like those. So we use mappings. Those are long lists telling us which obfuscated method name corresponds to a readable method name. In modern versions you have yarn (which is a community project), as well as official names from Mojang themselves, but in older versions, we just have MCP.</p> <p>Let's go through the process of how your normal Forge mod gets compiled:</p> <ul> <li>Download Minecraft (obfuscated by mojang)</li> <li>Actually download another copy of Minecraft (the server, also obfuscated)</li> <li>Merge the two JARs into one, so you can reference both server and client classes from the same mod</li> <li>Apply the MCP mappings to the JAR, turning Mojangs names into readable ones.</li> <li>Apply some patches to the JAR, to inject Forge events and custom registries and such.<ul> <li>the order of those first 5 steps isn't always the same. minecraft version and liveenv/devenv differences can rearrange them sometimes</li> </ul> </li> <li>Now you compile your mod source against this new Minecraft JAR (as well as some extra libraries)</li> <li>Forge in a live environment uses an intermediary between the completely obfuscated and the completely readable names, so now we need to turn our readable names back into intermediary ones</li> <li>For this, Forge goes through your generated JAR and applies the mappings from earlier, but in reverse</li> </ul> <p>This process has it's drawbacks. Especially that last step isn't perfect, and not everything you do will be remapped (and sometimes that is desired).</p> <p>Let's look at some examples:</p> <pre><code>public void myFunc() throws Throwable {\n    ItemStack itemStack = new ItemStack(/* ... */);\n    itemStack.getDisplayName();\n    ItemStack.class.getMethod(\"getDisplayName\").invoke(itemStack);\n    System.out.println(\"net.minecraft.item.ItemStack\");\n    System.out.println(\"ItemStack\");\n}\n</code></pre> <p>Now the forge remapper will take that code and get you something like this in the actual compiled mod:</p> <pre><code>public void myFunc() throws Throwable {\n    azq itemStack = new azq(/* ... */);\n    itemStack.b();\n    azq.class.getMethod(\"getDisplayName\").invoke(itemStack);\n    System.out.println(\"net.minecraft.item.ItemStack\");\n    System.out.println(\"ItemStack\");\n}\n</code></pre> <p>There are a few things that work and a few things don't in this snippet.</p> <p>The normal usage of <code>ItemStack</code> gets correctly replaced with <code>azq</code> the correct obfuscated name (well, in reality the obfuscated name would be a different one, but the basic idea holds) and the <code>getDisplayName</code> call gets replaced with <code>b</code>.</p> <p>But the reflection didn't work out so great. While the <code>.class</code> literal did get remapped, the <code>getMethod</code> argument didn't. And if we used <code>Class.forName</code> that would also not get remapped. This is because those values are just strings that just so happen to have the same name as a class or method. For this simple case, you might think we could just do some flow analysis and remap those values, but for more complicated cases (maybe the method name gets passed as an argument, or stored in a variable) the flow analysis is not that clear. Those cases could be covered, but doing so would lead to a lot of inconsistencies around the edges of our flow analysis. A simple refactor could lead to your code not being remapped correctly. In that light it is better to just not remap strings at all.</p> <p>The <code>println</code> is not changed either, but most likely those debug prints are not meant to change. If you later get an error relating to this method and you search for \"ItemStack\", you want to find those log entries in your log. So in this case the \"failed\" remap is actually the correct behaviour.</p> <p>Now given all this information, let's see how mixins handle remaps.</p>"},{"location":"mixins/advanced-injects/#refmaps","title":"Refmaps","text":"<p>Refmaps are mixins way around the forge compilation step. Mixins uses a lot of string identifiers. From method names in <code>@Inject(method = \"\")</code> to method descriptors in <code>@At(target = \"\", value = \"INVOKE\")</code>, to many more. All those strings are not recognized by Forge as something to be remapped, and even if Forge did remapping on strings, those strings are often in complicated formats that are wildly different from how Forge expects them. Because of this mixins instead use their own extra compilation step to remap all that information.</p> <p>The mixin refmap strategly looks like this:</p> <ul> <li>Compile against the deobfuscated (readable name) Minecraft JAR, like the normal mod.</li> <li>Let Forge take care of all the real java code (the method bodies, method arguments and return types, class references in annotations)</li> <li>Afterwards, take a look at all mixin annotations and resolve the things they refer to using the readable names.</li> <li>Then, since we are still in the development environment where those mappings are available, create a JSON file that contains all mappings relevant to all the mixin annotations.<ul> <li>Mixin doesn't just ship all the mappings because they are quite large and 99% not needed.</li> <li>This JSON file is called the \"refmap\"</li> </ul> </li> <li>Later, at runtime, when the Mixin class transformer parses the annotations to apply class transformations it reads the refmap and resolves annotation arguments using those names.</li> </ul> <p>You might run into a problem sometimes when referring to a non remapped method however. Not all methods in Minecrafts code are obfuscated. Some need to keep their original name in order to interact with other Java code. For example the <code>equals</code> method of an object needs to always be called <code>equals</code>. Obfuscating that method breaks comparisons used by a lot of Java standard library functions. When Mixin encounters those unobfuscated names during the refmap collection step, it notices the lack of a remapped name. This could mean that something is just named the same, but it could also mean that there is an error (the developmer mistyped a name). If you want to inform mixin that you are aware of a lacking mapping, you can do so by specifying <code>remap = false</code> on that annotation. It only applies to that specific annotation, so you might need to apply it to your <code>@Inject</code> and your <code>@At</code> separately.</p>"},{"location":"mixins/simple-injects/","title":"Simple Injects","text":"<p>Let's get into method modifications. The real interesting part of mixins. Hopefully you know the basics from the first two mixin tutorials by now, because now we get into a whole another layer of complexity.</p> <p>Now we will modify an existing method in Minecrafts code. This will allow us to react to changes in Minecrafts state. This is how almost all custom events are done, but we are of course not limited to just events that observe state changes. Using method modifying mixins we can change almost any behaviour in Minecrafts code.</p> <p>Note</p> <p>This is the simple tutorial, I will tell you how to use <code>@Inject</code>s and co, but I won't tell you the why. Check out the advanced tutorial for that.</p>"},{"location":"mixins/simple-injects/#the-easiest-of-the-easiest","title":"The easiest of the easiest","text":"<p>Let's start with probably the easiest <code>@Inject</code> out there. The <code>HEAD</code> inject. This mixin will inject whatever code you have inside your method at the start of the method you target.</p> <pre><code>@Mixin(PlayerControllerMP.class) // (1)!\npublic class RightClickWithItemEvent {\n\n    @Inject( // (2)!\n        method = \"sendUseItem\", // (3)!\n        at = @At(\"HEAD\")) // (4)!\n    private void onSendUseItem_mymod( // (5)!\n        EntityPlayer playerIn, World worldIn, ItemStack itemStackIn, // (6)!\n        CallbackInfoReturnable&lt;Boolean&gt; cir // (7)!\n        ) {\n        MinecraftForge.EVENT_BUS.post(new SendUseItemEvent(playerIn, worldIn, itemStackIn));\n    }\n}\n</code></pre> <ol> <li>First we declare which class we want to change </li> <li><code>@Inject</code> allows us to add code into an already existing method</li> <li>This sets the method into which we want to inject something. Be careful of overloaded methods here. Check out the advanced tutorial for more info.</li> <li>The <code>@At</code> specifies where our code will be injected. <code>HEAD</code> just means the top of the method.</li> <li>The injected code method should be <code>private</code> and <code>void</code> no matter what your target method is. You might also need to make your method <code>static</code></li> <li>You need to copy over all the parameters from your original method into which you are injecting.</li> <li>You need one extra parameter for the callback info.</li> </ol> <p>First we want to inject into the <code>PlayerControllerMP</code> class.</p> <p>We create an <code>@Inject</code>. This tells us in which method we want to inject (<code>sendUseItem</code>) and where in that method (<code>HEAD</code>, meaning the very top of the method).</p> <p>The actual method signature for an inject is always to return a <code>void</code>. You can make them <code>private</code> or <code>public</code>. The arguments are the same arguments as the method you want to inject into, as well as a <code>CallbackInfo</code>.</p> <p>For a method returning void, you just use a <code>CallbackInfo</code>, and if the method returns something, you use <code>CallbackInfoReturnable&lt;ReturnTypeOfTheInjectedIntoMethod&gt;</code>.</p> <p>Your method will now be called every time the <code>sendUseItem</code> is called with the arguments to that method and the <code>CallbackInfo</code>.</p> <p>Important</p> <p>Your method will be called at the beginning of the injected into method like this: </p> <pre><code>public boolean sendUseItem(EntityPlayer playerIn, World worldIn, ItemStack itemStackIn) {\n    onSendUseItem_mymod(playerIn, worldIn, itemStackIn, new CallbackInfo(/* ... */));\n    // All the other code that is normally in the method\n}\n</code></pre> <p>This means returning from your method will just continue as normal. See cancelling for info on how to return from the outer method.</p>"},{"location":"mixins/simple-injects/#at-a-method-call","title":"At a method call","text":"<p>Let's take this example method:</p> <pre><code>public void methodA() {\n    // Let's pretend lots of code calls methodA, so we don't want to inject\n    // ourselves into methodA\n}\n\npublic void methodB() {\n    System.out.println(\"Here 1\");\n    methodA();\n    // We want to inject our method call right here.\n    System.out.println(\"Here 2\");\n}\n</code></pre> <p>We can inject ourselves into <code>methodB</code> as well. It is just a bit more complicated than the <code>HEAD</code> inject.</p> <pre><code>@Inject(\n    method = \"methodB\", // (3)!\n    at = @At(\n        target = \"Lnet/some/Class;methodA()V\", // (1)!\n        value = \"INVOKE\")) // (2)!\nprivate void onMethodBJustCalledMethodA(CallbackInfo ci) {\n}\n</code></pre> <ol> <li>This is the method call for which we are searching. This is not the method into which our code will be injected.</li> <li>This tells mixin that we want <code>target</code> to point to a method call (not a field or anything else).</li> <li>This is the method into which we want our code to be injected.</li> </ol> <p>HUUUUH, where does that come from???</p> <p>Don't worry! I won't explain you how to understand these <code>target</code>s in this tutorial, but you also don't need to understand that <code>target</code>. Instead you can simply use the Minecraft Development IntelliJ Plugin to help you. Simply type <code>@At(value = \"INVOKE\", target = \"\")</code>, place your cursor inside of the target and use auto completion (Ctrl+Space) and the plugin will recommend you a bunch of method calls. Find whichever seems right to you and press enter. You can now (also thanks to the plugin) Ctrl click on the <code>target</code> string, which will take you to the decompiled code exactly to where that target will inject.</p>"},{"location":"mixins/simple-injects/#ordinals","title":"Ordinals","text":"<p>Let's take the <code>INVOKE</code> injection example from before and change it a bit:</p> <pre><code>public void methodA() {\n    // ...\n}\n\npublic void methodB() {\n    System.out.println(\"Here 1\");\n    if (Math.random() &lt; 0.4)\n        methodA();\n    System.out.println(\"Here 2\");\n    methodA();\n    // We want to inject our method call right here.\n    System.out.println(\"Here 3\");\n}\n</code></pre> <p>We can't simply use the same <code>@Inject</code> from before, since by default a <code>INVOKE</code> inject will inject just after every method call. Here, we can use the <code>ordinal</code> classifier to specify which method call we want to use. Keep in mind this is about where to place our injection, so many method calls in a loop will not increment the ordinal, only unique code locations that call the function will increase the ordinal. Remember: we are programmers, we start counting with <code>0</code>.</p> <pre><code>@Inject(method = \"methodB\", at = @At(target = \"Lnet/some/Class;methodA()V\", value = \"INVOKE\", ordinal = 1))\nprivate void onMethodBJustCalledMethodA(CallbackInfo ci) {\n}\n</code></pre>"},{"location":"mixins/simple-injects/#cancelling","title":"Cancelling","text":"<p>Cancelling a method means you return from the method you are injected to as soon as your injector method is done. In order to be able to use the cancelling methods, you need to mark your injection as cancellable.</p> <pre><code>@Inject(method = \"syncCurrentPlayItem\", at = @At(\"HEAD\"), cancellable = true)\nprivate void onSyncCurrentPlayItem_mymod(CallbackInfo ci) {\n    System.out.println(\"This code will be executed\");\n    if (Math.random() &lt; 0.5)\n        ci.cancel();\n    System.out.println(\"This code will *also* be executed\");\n    // As soon as this method returns, the outer method will see that it was cancelled and *also* return\n}\n\n@Inject(method = \"isHittingPosition\", at = @At(\"HEAD\"), cancellable = true)\nprivate void onIsHittingPosition_mymod(BlockPos pos, CallbackInfoReturnable&lt;Boolean&gt; cir) {\n    cir.setReturnValue(true);\n}\n</code></pre> <p>For <code>void</code> methods you need to use <code>callbackInfo.cancel()</code> which acts the same as a normal <code>return;</code> would in the method you are injecting into. For all other methods you need to use <code>callbackInfoReturnable.setReturnValue(returnValue)</code> which corresponds to <code>return returnValue;</code>.</p> <p>Important</p> <p>Cancelling a <code>CallbackInfo</code> will only have an effect as soon as you return from your injector method. The rest of your method will run as normal.</p>"}]}